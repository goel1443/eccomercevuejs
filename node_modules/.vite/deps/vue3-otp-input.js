import {
  Fragment,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  normalizeClass,
  onMounted,
  openBlock,
  ref,
  renderList,
  resolveComponent,
  unref,
  vModelDynamic,
  watch,
  withDirectives
} from "./chunk-EAUNOWDZ.js";
import "./chunk-PZ5AY32C.js";

// node_modules/vue3-otp-input/dist/vue3-otp-input.esm.js
var script$1 = defineComponent({
  name: "SingleOtpInput",
  props: {
    inputType: {
      type: String,
      validator: (value) => ["number", "tel", "letter-numeric", "password"].includes(value),
      default: "tel"
    },
    inputmode: {
      type: String,
      default: "numeric"
    },
    value: {
      type: [String, Number]
    },
    separator: {
      type: String
    },
    focus: {
      type: Boolean
    },
    inputClasses: {
      type: [String, Array]
    },
    conditionalClass: {
      type: String
    },
    shouldAutoFocus: {
      type: Boolean
    },
    isLastChild: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    isDisabled: {
      type: Boolean
    }
  },
  emits: ["on-change", "on-keydown", "on-paste", "on-focus", "on-blur"],
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const model = ref(props.value || "");
    const input = ref(null);
    const handleOnChange = () => {
      model.value = model.value.toString();
      if (model.value.length > 1) {
        model.value = model.value.slice(0, 1);
      }
      return emit("on-change", model.value);
    };
    const isCodeLetter = (charCode) => charCode >= 65 && charCode <= 90;
    const isCodeNumeric = (charCode) => charCode >= 48 && charCode <= 57 || charCode >= 96 && charCode <= 105;
    const handleOnKeyDown = (event) => {
      if (props.isDisabled) {
        event.preventDefault();
      }
      const keyEvent = event || window.event;
      const charCode = keyEvent.which ? keyEvent.which : keyEvent.keyCode;
      if (isCodeNumeric(charCode) || props.inputType === "letter-numeric" && isCodeLetter(charCode) || [8, 9, 13, 37, 39, 46, 86].includes(charCode)) {
        emit("on-keydown", event);
      } else {
        keyEvent.preventDefault();
      }
    };
    const handleOnPaste = (event) => emit("on-paste", event);
    const handleOnFocus = () => {
      input.value.select();
      return emit("on-focus");
    };
    const handleOnBlur = () => emit("on-blur");
    watch(() => props.value, (newValue, oldValue) => {
      if (newValue !== oldValue) {
        model.value = newValue;
      }
    });
    watch(() => props.focus, (newFocusValue, oldFocusValue) => {
      if (oldFocusValue !== newFocusValue && input.value && props.focus) {
        input.value.focus();
        input.value.select();
      }
    });
    onMounted(() => {
      if (input.value && props.focus && props.shouldAutoFocus) {
        input.value.focus();
        input.value.select();
      }
    });
    return {
      handleOnChange,
      handleOnKeyDown,
      handleOnPaste,
      handleOnFocus,
      handleOnBlur,
      input,
      model,
      inputTypeValue: props.inputType === "letter-numeric" ? "text" : props.inputType
    };
  }
});
var _hoisted_1$1 = {
  style: {
    "display": "flex",
    "align-items": "center"
  }
};
var _hoisted_2$1 = ["type", "inputmode", "placeholder", "disabled"];
var _hoisted_3 = {
  key: 0
};
var _hoisted_4 = ["innerHTML"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [withDirectives(createBaseVNode("input", {
    "data-test": "single-input",
    type: _ctx.inputTypeValue,
    inputmode: _ctx.inputmode,
    placeholder: _ctx.placeholder,
    disabled: _ctx.isDisabled,
    ref: "input",
    min: "0",
    max: "9",
    maxlength: "1",
    pattern: "[0-9]",
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
    class: normalizeClass([_ctx.inputClasses, _ctx.conditionalClass, {
      "is-complete": _ctx.model
    }]),
    onInput: _cache[1] || (_cache[1] = function() {
      return _ctx.handleOnChange && _ctx.handleOnChange(...arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function() {
      return _ctx.handleOnKeyDown && _ctx.handleOnKeyDown(...arguments);
    }),
    onPaste: _cache[3] || (_cache[3] = function() {
      return _ctx.handleOnPaste && _ctx.handleOnPaste(...arguments);
    }),
    onFocus: _cache[4] || (_cache[4] = function() {
      return _ctx.handleOnFocus && _ctx.handleOnFocus(...arguments);
    }),
    onBlur: _cache[5] || (_cache[5] = function() {
      return _ctx.handleOnBlur && _ctx.handleOnBlur(...arguments);
    })
  }, null, 42, _hoisted_2$1), [[vModelDynamic, _ctx.model]]), !_ctx.isLastChild && _ctx.separator ? (openBlock(), createElementBlock("span", _hoisted_3, [createBaseVNode("span", {
    innerHTML: _ctx.separator
  }, null, 8, _hoisted_4)])) : createCommentVNode("", true)]);
}
script$1.render = render$1;
var BACKSPACE = 8;
var LEFT_ARROW = 37;
var RIGHT_ARROW = 39;
var DELETE = 46;
var script = defineComponent({
  name: "Vue3OtpInput",
  components: {
    SingleOtpInput: script$1
  },
  props: {
    value: {
      type: String,
      default: "",
      required: true
    },
    numInputs: {
      default: 4
    },
    separator: {
      type: String,
      default: "**"
    },
    inputClasses: {
      type: [String, Array]
    },
    conditionalClass: {
      type: Array,
      default: []
    },
    inputType: {
      type: String,
      validator: (value) => ["number", "tel", "letter-numeric", "password"].includes(value)
    },
    inputmode: {
      type: String,
      validator: (value) => ["numeric", "text", "tel", "none"].includes(value),
      default: "numeric"
    },
    shouldAutoFocus: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: Array,
      default: []
    },
    isDisabled: {
      type: Boolean,
      default: false
    },
    shouldFocusOrder: {
      type: Boolean,
      default: false
    }
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const activeInput = ref(0);
    const otp = ref([]);
    const oldOtp = ref([]);
    watch(() => props.value, (val) => {
      const fill = unref(val).split("");
      otp.value = fill;
    }, {
      immediate: true
    });
    const handleOnFocus = (index) => {
      activeInput.value = index;
    };
    const handleOnBlur = () => {
      activeInput.value = -1;
    };
    const checkFilledAllInputs = () => {
      if (otp.value.join("").length === props.numInputs) {
        emit("update:value", otp.value.join(""));
        return emit("on-complete", otp.value.join(""));
      }
      return "Wait until the user enters the required number of characters";
    };
    const focusInput = (input) => {
      activeInput.value = Math.max(Math.min(props.numInputs - 1, input), 0);
    };
    const focusNextInput = () => {
      focusInput(activeInput.value + 1);
    };
    const focusPrevInput = () => {
      focusInput(activeInput.value - 1);
    };
    const changeCodeAtFocus = (value) => {
      oldOtp.value = Object.assign([], otp.value);
      otp.value[activeInput.value] = value;
      if (oldOtp.value.join("") !== otp.value.join("")) {
        emit("update:value", otp.value.join(""));
        emit("on-change", otp.value.join(""));
        checkFilledAllInputs();
      }
    };
    const handleOnPaste = (event) => {
      event.preventDefault();
      const pastedData = event.clipboardData.getData("text/plain").slice(0, props.numInputs - activeInput.value).split("");
      if (props.inputType === "number" && !pastedData.join("").match(/^\d+$/)) {
        return "Invalid pasted data";
      }
      if (props.inputType === "letter-numeric" && !pastedData.join("").match(/^\w+$/)) {
        return "Invalid pasted data";
      }
      const currentCharsInOtp = otp.value.slice(0, activeInput.value);
      const combinedWithPastedData = currentCharsInOtp.concat(pastedData);
      combinedWithPastedData.slice(0, props.numInputs).forEach(function(value, i) {
        otp.value[i] = value;
      });
      focusInput(combinedWithPastedData.slice(0, props.numInputs).length);
      return checkFilledAllInputs();
    };
    const handleOnChange = (value) => {
      changeCodeAtFocus(value);
      focusNextInput();
    };
    const clearInput = () => {
      if (otp.value.length > 0) {
        emit("update:value", "");
        emit("on-change", "");
      }
      otp.value = [];
      activeInput.value = 0;
    };
    const fillInput = (value) => {
      const fill = value.split("");
      if (fill.length === props.numInputs) {
        otp.value = fill;
        emit("update:value", otp.value.join(""));
        emit("on-complete", otp.value.join(""));
      }
    };
    const handleOnKeyDown = (event, index) => {
      switch (event.keyCode) {
        case BACKSPACE:
          event.preventDefault();
          changeCodeAtFocus("");
          focusPrevInput();
          break;
        case DELETE:
          event.preventDefault();
          changeCodeAtFocus("");
          break;
        case LEFT_ARROW:
          event.preventDefault();
          focusPrevInput();
          break;
        case RIGHT_ARROW:
          event.preventDefault();
          focusNextInput();
          break;
        default:
          focusOrder(index);
          break;
      }
    };
    const focusOrder = (currentIndex) => {
      if (props.shouldFocusOrder) {
        setTimeout(() => {
          const len = otp.value.join("").length;
          if (currentIndex - len >= 0) {
            activeInput.value = len;
            otp.value[currentIndex] = "";
          }
        }, 100);
      }
    };
    return {
      activeInput,
      otp,
      oldOtp,
      clearInput,
      handleOnPaste,
      handleOnKeyDown,
      handleOnBlur,
      changeCodeAtFocus,
      focusInput,
      focusNextInput,
      focusPrevInput,
      handleOnFocus,
      checkFilledAllInputs,
      handleOnChange,
      fillInput
    };
  }
});
var _hoisted_1 = {
  style: {
    "display": "flex"
  },
  class: "otp-input-container"
};
var _hoisted_2 = {
  key: 0,
  autocomplete: "off",
  name: "hidden",
  type: "text",
  style: {
    "display": "none"
  }
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SingleOtpInput = resolveComponent("SingleOtpInput");
  return openBlock(), createElementBlock("div", _hoisted_1, [_ctx.inputType === "password" ? (openBlock(), createElementBlock("input", _hoisted_2)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.numInputs, (_, i) => {
    return openBlock(), createBlock(_component_SingleOtpInput, {
      key: i,
      focus: _ctx.activeInput === i,
      value: _ctx.otp[i],
      separator: _ctx.separator,
      "input-type": _ctx.inputType,
      inputmode: _ctx.inputmode,
      "input-classes": _ctx.inputClasses,
      conditionalClass: _ctx.conditionalClass[i],
      "is-last-child": i === _ctx.numInputs - 1,
      "should-auto-focus": _ctx.shouldAutoFocus,
      placeholder: _ctx.placeholder[i],
      "is-disabled": _ctx.isDisabled,
      onOnChange: _ctx.handleOnChange,
      onOnKeydown: ($event) => _ctx.handleOnKeyDown($event, i),
      onOnPaste: _ctx.handleOnPaste,
      onOnFocus: ($event) => _ctx.handleOnFocus(i),
      onOnBlur: _ctx.handleOnBlur
    }, null, 8, ["focus", "value", "separator", "input-type", "inputmode", "input-classes", "conditionalClass", "is-last-child", "should-auto-focus", "placeholder", "is-disabled", "onOnChange", "onOnKeydown", "onOnPaste", "onOnFocus", "onOnBlur"]);
  }), 128))]);
}
script.render = render;
var entry_esm = (() => {
  const installable = script;
  installable.install = (app) => {
    app.component("Vue3OtpInput", installable);
  };
  return installable;
})();
export {
  entry_esm as default
};
//# sourceMappingURL=vue3-otp-input.js.map
